# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2024, ETH Zurich
# All rights reserved.
#
# Please, refer to the LICENSE file in the root directory.
# SPDX-License-Identifier: BSD-3-Clause

from __future__ import annotations

import pytest
import copy
import numpy as np

dace = pytest.importorskip("dace")
import dace
from dace.sdfg import nodes as dace_nodes

from gt4py.next.program_processors.runners.dace import (
    transformations as gtx_transformations,
)

from . import util


def _perform_test(
    sdfg: dace.SDFG,
    explected_applies: int,
    removed_transients: set[str] | None = None,
) -> None:
    assert dace.Config.get("compiler.use_cache") == False
    ref = {
        name: np.array(np.random.rand(*desc.shape), copy=True, dtype=desc.dtype.as_numpy_dtype())
        for name, desc in sdfg.arrays.items()
        if not desc.transient
    }
    res = copy.deepcopy(ref)

    if removed_transients is not None:
        assert removed_transients.issubset(
            name for name, desc in sdfg.arrays.items() if desc.transient
        )

    if explected_applies != 0:
        util.compile_and_run_sdfg(sdfg, **ref)

    nb_apply = gtx_transformations.gt_split_access_nodes(
        sdfg=sdfg,
        validate=True,
        validate_all=True,
    )
    assert nb_apply == explected_applies

    if explected_applies == 0:
        return

    util.compile_and_run_sdfg(sdfg, **res)
    assert all(np.allclose(ref[name], res[name]) for name in ref.keys())

    if removed_transients is not None:
        assert all(
            name not in removed_transients for name, desc in sdfg.arrays.items() if desc.transient
        )


def test_map_producer_ac_consumer():
    """The data is generated by a Map and then consumed by an AccessNode."""
    sdfg = dace.SDFG(util.unique_name("map_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcd":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer",
        map_ranges={"__i": "0:5"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i + 10]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_nedge(t, state.add_access("b"), dace.Memlet("t[10:15] -> [3:8]"))

    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[0:10] -> [0:10]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[0:10] -> [3:13]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_map_producer_map_consumer():
    """The data is generated by a Map and then consumed by another Map."""
    sdfg = dace.SDFG(util.unique_name("map_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcd":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer",
        map_ranges={"__i": "0:5"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i + 10]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer",
        map_ranges={"__i": "10:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("b[__i - 7]")},
        input_nodes={t},
        external_edges=True,
    )

    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[0:10] -> [0:10]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[0:10] -> [3:13]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_ac_producer_ac_consumer():
    sdfg = dace.SDFG(util.unique_name("ac_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcd":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:21] -> [5:15]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [20:30]"))

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[5:15] -> [0:10]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[20:30] -> [22:32]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_ac_producer_map_consumer():
    sdfg = dace.SDFG(util.unique_name("ac_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcd":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[1:11] -> [0:10]"))
    state.add_mapped_tasklet(
        "consumer",
        map_ranges={"__i": "5:10"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("b[__i + 7]")},
        input_nodes={t},
        external_edges=True,
    )

    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[0:10] -> [10:20]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[10:20] -> [3:13]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_simple_splitable_ac_source_not_full_consume():
    """Similar to `test_simple_splitable_ac_source_full_consume`, but one consumer
    does not fully consumer what is produced.
    """
    sdfg = dace.SDFG(util.unique_name("simple_splitable_ac_source_not_full_consume"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:21] -> [5:15]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [20:30]"))

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[7:12] -> [1:6]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[5:15] -> [8:18]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[20:30] -> [22:32]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_simple_splitable_ac_source_multiple_consumer():
    """Similar to `test_simple_splitable_ac_source_not_full_consume`, but there are
    multiple consumer, per producer.
    """
    sdfg = dace.SDFG(util.unique_name("simple_splitable_ac_source_multiple_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:21] -> [5:15]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [20:30]"))

    state.add_nedge(
        t,
        state.add_access("c"),
        # Only a subset is consumed.
        dace.Memlet("t[7:12] -> [1:6]"),
    )
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[20:30] -> [22:32]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[20:30] -> [12:22]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def _make_transient_producer_sdfg(
    partial_read: bool,
) -> dace.SDFG:
    """Data is generated by a transient.

    The read from the intermediate transient is can either be partial or full
    depending on the value of `partial_read`.
    """
    sdfg = dace.SDFG(
        util.unique_name("partial_ac_read" + ("_partial_read" if partial_read else "_full_read"))
    )
    state = sdfg.add_state(is_start_block=True)
    for name in ["a", "b", "c", "d", "t1", "t2"]:
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=name.startswith("t"),
        )
    t1 = state.add_access("t1")
    t2 = state.add_access("t2")

    state.add_nedge(state.add_access("a"), t1, dace.Memlet("t1[0:20] -> [0:20]"))
    state.add_nedge(t1, t2, dace.Memlet("t1[0:10] -> [0:10]"))

    if partial_read:
        state.add_nedge(t2, state.add_access("b"), dace.Memlet("t2[0:9] -> [0:9]"))
    else:
        state.add_nedge(t2, state.add_access("b"), dace.Memlet("t2[0:10] -> [0:10]"))

    state.add_nedge(state.add_access("c"), t2, dace.Memlet("c[10:20] -> [10:20]"))
    state.add_nedge(t2, state.add_access("d"), dace.Memlet("t2[10:20] -> [10:20]"))
    sdfg.validate()

    return sdfg


def test_transient_producer_full_read():
    # Because the read is performed in full, the transformation applies.
    sdfg = _make_transient_producer_sdfg(partial_read=False)
    _perform_test(sdfg, explected_applies=1, removed_transients={"t2"})


def test_transient_producer_partial_read():
    # Because the read from the intermediate is only partial the transformation
    #  does not apply. This might change in newer versions.
    sdfg = _make_transient_producer_sdfg(partial_read=True)
    _perform_test(sdfg, explected_applies=0)


def test_overlapping_consume_ac_source():
    """There are 2 producers, but only one consumer that needs both producers."""
    sdfg = dace.SDFG(util.unique_name("overlapping_consume_ac_source"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtc":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[1:11] -> [0:10]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[2:12] -> [10:20]"))
    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[0:20] -> [0:20]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=0)


def _make_map_producer_multiple_consumer(
    partial_read: bool,
) -> dace.SDFG:
    """Creates an SDFG with a Map producer and multiple consumer.

    The Map generates a certain amount of data. That is fully read by another Map.
    The same data is also read by an AccessNode, depending on the value of
    `partial_read` it will either read the full data for only parts of it.
    """
    sdfg = dace.SDFG(
        util.unique_name(
            "map_producer_map_consumer" + ("_partial_read" if partial_read else "_full_read")
        )
    )
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer",
        map_ranges={"__i": "0:5"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i + 10]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer",
        map_ranges={"__i": "10:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("b[__i - 7]")},
        input_nodes={t},
        external_edges=True,
    )

    if partial_read:
        state.add_nedge(t, state.add_access("e"), dace.Memlet("t[10:14] -> [3:7]"))
    else:
        state.add_nedge(t, state.add_access("e"), dace.Memlet("t[10:15] -> [3:8]"))

    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[0:10] -> [0:10]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[0:10] -> [3:13]"))
    sdfg.validate()
    return sdfg


def test_map_producer_multi_consumer_fullread():
    # Because the data is fully read that transformation will apply.
    sdfg = _make_map_producer_multiple_consumer(partial_read=False)
    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_map_producer_multi_consumer_partialread():
    # Because the data is only partially read, the transformation will not apply.
    #  This might change in the future.
    sdfg = _make_map_producer_multiple_consumer(partial_read=True)
    _perform_test(sdfg, explected_applies=0)


def test_same_producer():
    sdfg = dace.SDFG(util.unique_name("same_producer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abt":
        sdfg.add_array(
            name,
            shape=(20,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    a, b, t = (state.add_access(name) for name in "abt")

    me, mx = state.add_map("map", ndrange={"__i": "0:10"})
    tlet1 = state.add_tasklet(
        "comp1",
        inputs={"__in1", "__in2"},
        outputs={"__out"},
        code="__out = __in1 + __in2",
    )
    tlet2 = state.add_tasklet(
        "comp2",
        inputs={"__in1", "__in2"},
        outputs={"__out"},
        code="__out = __in1 - __in2",
    )

    state.add_edge(a, None, me, "IN_a1", dace.Memlet("a[0:10]"))
    state.add_edge(a, None, me, "IN_a2", dace.Memlet("a[10:20]"))
    state.add_edge(me, "OUT_a1", tlet1, "__in1", dace.Memlet("a[__i]"))
    state.add_edge(me, "OUT_a2", tlet1, "__in2", dace.Memlet("a[__i + 10]"))
    state.add_edge(me, "OUT_a1", tlet2, "__in1", dace.Memlet("a[__i]"))
    state.add_edge(me, "OUT_a2", tlet2, "__in2", dace.Memlet("a[__i + 10]"))
    me.add_scope_connectors("a1")
    me.add_scope_connectors("a2")

    state.add_edge(tlet1, "__out", mx, "IN_t1", dace.Memlet("t[__i]"))
    state.add_edge(mx, "OUT_t1", t, None, dace.Memlet("t[0:10]"))
    state.add_edge(tlet2, "__out", mx, "IN_t2", dace.Memlet("t[__i + 10]"))
    state.add_edge(mx, "OUT_t2", t, None, dace.Memlet("t[10:20]"))
    mx.add_scope_connectors("t1")
    mx.add_scope_connectors("t2")

    state.add_nedge(t, b, dace.Memlet("t[0:10] -> [10:20]"))
    state.add_nedge(t, b, dace.Memlet("t[10:20] -> [0:10]"))
    sdfg.validate()

    _perform_test(sdfg, explected_applies=1, removed_transients={"t"})


def test_map_producer_complex_map_consumer():
    """The data are generated by two Map producers, which are consumed by 3 Map consumers.
    a[5:10] -> t[5:10]
    b[10:20] -> t[10:20]
    c[20:25] -> t[20:25]
    t[5:15] -> d[5:15]
    t[15:25] -> e[15:25]
    We expect the Map producers to be split into 4 Maps:
    a[5:10] -> d[5:10]
    b[10:15] -> d[10:15]
    b[15:20] -> e[15:20]
    c[20:25] -> e[20:25]
    """
    sdfg = dace.SDFG(util.unique_name("map_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:10"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "10:20"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_c",
        map_ranges={"__i": "20:25"},
        inputs={"__in": dace.Memlet("c[__i]")},
        code="__out = __in + 12.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_map_producer_map_consumer_complex():
    """The data is generated by a Map and then consumed by another Map."""
    sdfg = dace.SDFG(util.unique_name("map_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_mapped_tasklet(
        "consumer_c",
        map_ranges={"__i": "5:10"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 12.0",
        outputs={"__out": dace.Memlet("c[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "10:20"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "20:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()
    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_map_producer_ac_consumer_complex():
    """The data is generated by 2 Maps and consumed by 3 AccessNodes.
    a[5:15] -> t[5:15]
    b[15:25] -> t[15:25]
    t[5:10] -> c[0:5]
    t[10:20] -> d[11:21]
    t[20:25] -> e[14:19]
    We expect the Maps to be split into 4 Maps:
    a[5:10] -> c[0:5]
    a[10:15] -> d[11:16]
    b[15:20] -> d[16:21]
    b[20:25] -> e[14:19]
    """
    pytest.xfail(
        "Test is currently expected to fail due to missing support for splitting access"
        " nodes that have as inputs Maps whose outputs are assigned to AccessNodes."
    )

    sdfg = dace.SDFG(util.unique_name("map_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[5:10] -> [0:5]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[10:20] -> [11:21]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[20:25] -> [14:19]"))
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )

    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_ac_producer_complex_map_consumer():
    """The data are read from 3 AccessNodes and consumed by 2 Maps.
    a[6:11] -> t[5:10]
    b[13:23] -> t[10:20]
    c[14:19] -> t[20:25]
    t[5:15] -> d[5:15]
    t[15:25] -> e[15:25]
    We expect the AccessNodes to be split into 4 Maps:
    a[6:11] -> d[5:10]
    b[13:18] -> d[10:15]
    b[18:23] -> e[15:20]
    c[14:19] -> e[20:25]
    """
    pytest.xfail(
        "Test is currently expected to fail due to missing support for splitting access"
        " nodes that have AccessNodes as input and Maps as outputs."
    )

    sdfg = dace.SDFG(util.unique_name("map_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[6:11] -> [5:10]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[13:23] -> [10:20]"))
    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[14:19] -> [20:25]"))

    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )

    pytest.xfail("This test is currently expected to fail due to known issue #1234")

    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_ac_producer_complex_ac_consumer():
    """The data is generated by 3 AccessNodes and consumed by 2 AccessNodes.
    a[11:16] -> t[5:10]
    b[28:38] -> t[10:20]
    c[14:19] -> t[20:25]
    t[5:15] -> d[0:10]
    t[15:25] -> e[22:32]
    We expect the transient AccessNode to be replaced with the following edges:
    a[11:16] -> d[0:5]
    b[28:33] -> d[5:10]
    b[33:38] -> e[22:27]
    c[14:19] -> e[27:32]
    """
    sdfg = dace.SDFG(util.unique_name("ac_producer_complex_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:16] -> [5:10]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [10:20]"))
    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[14:19] -> [20:25]"))

    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[5:15] -> [0:10]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[15:25] -> [22:32]"))
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    edges = [edge for edge, _ in opt_sdfg.all_edges_recursive()]
    assert len(edges) == 4
    # check that the edges have the expected src, dst and volume
    assert any(
        edge.src.label == "a" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "c" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )


def test_ac_producer_ac_consumer_complex():
    """The data is generated by 2 AccessNodes and consumed by 3 AccessNodes.
    a[11:21] -> t[5:15]
    b[28:38] -> t[15:25]
    t[5:10] -> c[0:5]
    t[10:20] -> d[22:32]
    t[20:25] -> e[34:39]
    We expect the transient AccessNode to be replaced with the following edges:
    a[11:16] -> c[0:5]
    a[16:21] -> d[22:27]
    b[28:33] -> d[27:32]
    b[33:38] -> e[34:39]
    """
    sdfg = dace.SDFG(util.unique_name("ac_producer_ac_consumer_complex"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:21] -> [5:15]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [15:25]"))

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[5:10] -> [0:5]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[10:20] -> [22:32]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[20:25] -> [34:39]"))

    sdfg.validate()
    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    edges = [edge for edge, _ in opt_sdfg.all_edges_recursive()]
    assert len(edges) == 4
    # check that the edges have the expected src, dst and volume
    assert any(
        edge.src.label == "a" and edge.dst.label == "c" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "a" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )
