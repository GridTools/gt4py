# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2024, ETH Zurich
# All rights reserved.
#
# Please, refer to the LICENSE file in the root directory.
# SPDX-License-Identifier: BSD-3-Clause

from __future__ import annotations

import pytest
import copy
import numpy as np

dace = pytest.importorskip("dace")
from dace.sdfg import nodes as dace_nodes

from gt4py.next.program_processors.runners.dace import (
    transformations as gtx_transformations,
)

from . import util

import dace


def test_map_producer_complex_map_consumer():
    """The data are generated by two Map producers, which are consumed by 3 Map consumers.
    a[5:10] -> t[5:10]
    b[10:20] -> t[10:20]
    c[20:25] -> t[20:25]
    t[5:15] -> d[5:15]
    t[15:25] -> e[15:25]
    We expect the Map producers to be split into 4 Maps:
    a[5:10] -> d[5:10]
    b[10:15] -> d[10:15]
    b[15:20] -> e[15:20]
    c[20:25] -> e[20:25]
    """
    sdfg = dace.SDFG(util.unique_name("map_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:10"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "10:20"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_c",
        map_ranges={"__i": "20:25"},
        inputs={"__in": dace.Memlet("c[__i]")},
        code="__out = __in + 12.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_map_producer_map_consumer_complex():
    """The data is generated by a Map and then consumed by another Map."""
    sdfg = dace.SDFG(util.unique_name("map_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_mapped_tasklet(
        "consumer_c",
        map_ranges={"__i": "5:10"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 12.0",
        outputs={"__out": dace.Memlet("c[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "10:20"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "20:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()
    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_map_producer_ac_consumer_complex():
    """The data is generated by 2 Maps and consumed by 3 AccessNodes.
    a[5:15] -> t[5:15]
    b[15:25] -> t[15:25]
    t[5:10] -> c[0:5]
    t[10:20] -> d[11:21]
    t[20:25] -> e[14:19]
    We expect the Maps to be split into 4 Maps:
    a[5:10] -> c[0:5]
    a[10:15] -> d[11:16]
    b[15:20] -> d[16:21]
    b[20:25] -> e[14:19]
    """
    pytest.xfail(
        "Test is currently expected to fail due to missing support for splitting access"
        " nodes that have as inputs Maps whose outputs are assigned to AccessNodes."
    )

    sdfg = dace.SDFG(util.unique_name("map_producer_map_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_mapped_tasklet(
        "producer_a",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("a[__i]")},
        code="__out = __in + 10.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "producer_b",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("b[__i]")},
        code="__out = __in + 11.0",
        outputs={"__out": dace.Memlet("t[__i]")},
        output_nodes={t},
        external_edges=True,
    )

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[5:10] -> [0:5]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[10:20] -> [11:21]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[20:25] -> [14:19]"))
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )

    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_ac_producer_complex_map_consumer():
    """The data are read from 3 AccessNodes and consumed by 2 Maps.
    a[6:11] -> t[5:10]
    b[13:23] -> t[10:20]
    c[14:19] -> t[20:25]
    t[5:15] -> d[5:15]
    t[15:25] -> e[15:25]
    We expect the AccessNodes to be split into 4 Maps:
    a[6:11] -> d[5:10]
    b[13:18] -> d[10:15]
    b[18:23] -> e[15:20]
    c[14:19] -> e[20:25]
    """
    pytest.xfail(
        "Test is currently expected to fail due to missing support for splitting access"
        " nodes that have AccessNodes as input and Maps as outputs."
    )

    sdfg = dace.SDFG(util.unique_name("map_producer_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(25,),
            dtype=dace.float64,
            transient=(name == "t"),
        )
    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[6:11] -> [5:10]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[13:23] -> [10:20]"))
    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[14:19] -> [20:25]"))

    state.add_mapped_tasklet(
        "consumer_d",
        map_ranges={"__i": "5:15"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 13.0",
        outputs={"__out": dace.Memlet("d[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    state.add_mapped_tasklet(
        "consumer_e",
        map_ranges={"__i": "15:25"},
        inputs={"__in": dace.Memlet("t[__i]")},
        code="__out = __in + 14.0",
        outputs={"__out": dace.Memlet("e[__i]")},
        input_nodes={t},
        external_edges=True,
    )
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )

    pytest.xfail("This test is currently expected to fail due to known issue #1234")

    maps = [n for n, _ in opt_sdfg.all_nodes_recursive() if isinstance(n, dace_nodes.MapEntry)]
    assert len(maps) == 4
    # Check that the maps have the expected ranges
    assert any(str(m.map.range) == "5:10" for m in maps)
    assert any(str(m.map.range) == "10:15" for m in maps)
    assert any(str(m.map.range) == "15:20" for m in maps)
    assert any(str(m.map.range) == "20:25" for m in maps)


def test_ac_producer_complex_ac_consumer():
    """The data is generated by 3 AccessNodes and consumed by 2 AccessNodes.
    a[11:16] -> t[5:10]
    b[28:38] -> t[10:20]
    c[14:19] -> t[20:25]
    t[5:15] -> d[0:10]
    t[15:25] -> e[22:32]
    We expect the transient AccessNode to be replaced with the following edges:
    a[11:16] -> d[0:5]
    b[28:33] -> d[5:10]
    b[33:38] -> e[22:27]
    c[14:19] -> e[27:32]
    """
    sdfg = dace.SDFG(util.unique_name("ac_producer_complex_ac_consumer"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:16] -> [5:10]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [10:20]"))
    state.add_nedge(state.add_access("c"), t, dace.Memlet("c[14:19] -> [20:25]"))

    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[5:15] -> [0:10]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[15:25] -> [22:32]"))
    sdfg.validate()

    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    edges = [edge for edge, _ in opt_sdfg.all_edges_recursive()]
    assert len(edges) == 4
    # check that the edges have the expected src, dst and volume
    assert any(
        edge.src.label == "a" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "c" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )


def test_ac_producer_ac_consumer_complex():
    """The data is generated by 2 AccessNodes and consumed by 3 AccessNodes.
    a[11:21] -> t[5:15]
    b[28:38] -> t[15:25]
    t[5:10] -> c[0:5]
    t[10:20] -> d[22:32]
    t[20:25] -> e[34:39]
    We expect the transient AccessNode to be replaced with the following edges:
    a[11:16] -> c[0:5]
    a[16:21] -> d[22:27]
    b[28:33] -> d[27:32]
    b[33:38] -> e[34:39]
    """
    sdfg = dace.SDFG(util.unique_name("ac_producer_ac_consumer_complex"))
    state = sdfg.add_state(is_start_block=True)

    for name in "abtcde":
        sdfg.add_array(
            name,
            shape=(40,),
            dtype=dace.float64,
            transient=(name == "t"),
        )

    t = state.add_access("t")

    state.add_nedge(state.add_access("a"), t, dace.Memlet("a[11:21] -> [5:15]"))
    state.add_nedge(state.add_access("b"), t, dace.Memlet("b[28:38] -> [15:25]"))

    state.add_nedge(t, state.add_access("c"), dace.Memlet("t[5:10] -> [0:5]"))
    state.add_nedge(t, state.add_access("d"), dace.Memlet("t[10:20] -> [22:32]"))
    state.add_nedge(t, state.add_access("e"), dace.Memlet("t[20:25] -> [34:39]"))

    sdfg.validate()
    opt_sdfg = gtx_transformations.gt_auto_optimize(
        sdfg,
        sdfg_name=sdfg.name,
        gpu=False,
        validate=True,
    )
    edges = [edge for edge, _ in opt_sdfg.all_edges_recursive()]
    assert len(edges) == 4
    # check that the edges have the expected src, dst and volume
    assert any(
        edge.src.label == "a" and edge.dst.label == "c" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "a" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "d" and edge.data.volume == 5 for edge in edges
    )
    assert any(
        edge.src.label == "b" and edge.dst.label == "e" and edge.data.volume == 5 for edge in edges
    )
