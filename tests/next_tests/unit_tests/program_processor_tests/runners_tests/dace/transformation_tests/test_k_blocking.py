# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2024, ETH Zurich
# All rights reserved.
#
# Please, refer to the LICENSE file in the root directory.
# SPDX-License-Identifier: BSD-3-Clause

from typing import Callable
import dace
import copy
import numpy as np

from dace.sdfg import nodes as dace_nodes

from gt4py.next.program_processors.runners.dace_fieldview import (
    transformations as gtx_transformations,
)


def _get_simple_sdfg() -> tuple[dace.SDFG, Callable[[np.ndarray, np.ndarray], np.ndarray]]:
    """Creates a simple SDFG.

    The k blocking transformation can be applied to the SDFG, however no node
    can be taken out. This is because how it is constructed. However, applying
    some simplistic transformations this can be done.
    """
    sdfg = dace.SDFG("only_dependent")
    state = sdfg.add_state("state", is_start_block=True)
    sdfg.add_symbol("N", dace.int32)
    sdfg.add_symbol("M", dace.int32)
    _, a = sdfg.add_array("a", ("N", "M"), dace.float64, transient=False)
    _, b = sdfg.add_array("b", ("N",), dace.float64, transient=False)
    _, c = sdfg.add_array("c", ("N", "M"), dace.float64, transient=False)
    state.add_mapped_tasklet(
        name="comp",
        map_ranges=dict(i=f"0:N", j=f"0:M"),
        inputs=dict(__in0=dace.Memlet("a[i, j]"), __in1=dace.Memlet("b[i]")),
        outputs=dict(__out=dace.Memlet("c[i, j]")),
        code="__out = __in0 + __in1",
        external_edges=True,
    )
    return sdfg, lambda a, b: a + b.reshape((-1, 1))


def test_only_dependent():
    """Just applying the transformation to the SDFG.

    Because all of nodes (which is only a Tasklet) inside the map scope are
    "dependent", see the transformation for explanation of terminology, the
    transformation will only add an inner map.
    """
    sdfg, reff = _get_simple_sdfg()

    N, M = 100, 10
    a = np.random.rand(N, M)
    b = np.random.rand(N)
    c = np.zeros_like(a)
    ref = reff(a, b)

    # Apply the transformation
    sdfg.apply_transformations_repeated(
        gtx_transformations.KBlocking(blocking_size=10, block_dim="j"),
        validate=True,
        validate_all=True,
    )

    assert len(sdfg.states()) == 1
    state = sdfg.states()[0]
    source_nodes = state.source_nodes()
    assert len(source_nodes) == 2
    assert all(isinstance(x, dace_nodes.AccessNode) for x in source_nodes)
    source_node = source_nodes[0]  # Unspecific which one it is, but it does not matter.
    assert state.out_degree(source_node) == 1
    outer_map: dace_nodes.MapEntry = next(iter(state.out_edges(source_node))).dst
    assert isinstance(outer_map, dace_nodes.MapEntry)
    assert state.in_degree(outer_map) == 2
    assert state.out_degree(outer_map) == 2
    assert len(outer_map.map.params) == 2
    assert "j" not in outer_map.map.params
    assert all(isinstance(x.dst, dace_nodes.MapEntry) for x in state.out_edges(outer_map))
    inner_map: dace_nodes.MapEntry = next(iter(state.out_edges(outer_map))).dst
    assert len(inner_map.map.params) == 1
    assert inner_map.map.params[0] == "j"
    assert inner_map.map.schedule == dace.dtypes.ScheduleType.Sequential

    sdfg(a=a, b=b, c=c, N=N, M=M)
    assert np.allclose(ref, c)


def test_intermediate_access_node():
    """Test the lifting out, version "AccessNode".

    The Tasklet of the SDFG generated by `_get_simple_sdfg()` has to be inside the
    inner most loop because one of its input Memlet depends on `j`. However,
    one of its input, `b[i]` does not. Instead of connecting `b` directly with the
    Tasklet, this test will store `b[i]` inside a temporary inside the Map.
    This access node is independent of `j` and can thus be moved out of the inner
    most scope.
    """
    sdfg, reff = _get_simple_sdfg()

    N, M = 100, 10
    a = np.random.rand(N, M)
    b = np.random.rand(N)
    c = np.zeros_like(a)
    ref = reff(a, b)

    # Now make a small modification is such that the transformation does something.
    state = sdfg.states()[0]
    sdfg.add_scalar("tmp", dace.float64, transient=True)

    tmp = state.add_access("tmp")
    edge = next(
        e for e in state.edges() if isinstance(e.src, dace_nodes.MapEntry) and e.data.data == "b"
    )
    state.add_edge(edge.src, edge.src_conn, tmp, None, copy.deepcopy(edge.data))
    state.add_edge(tmp, None, edge.dst, edge.dst_conn, dace.Memlet("tmp[0]"))
    state.remove_edge(edge)

    # Test if after the modification the SDFG still works
    sdfg(a=a, b=b, c=c, N=N, M=M)
    assert np.allclose(ref, c)

    # Apply the transformation.
    sdfg.apply_transformations_repeated(
        gtx_transformations.KBlocking(blocking_size=10, block_dim="j"),
        validate=True,
        validate_all=True,
    )

    # Inspect if the SDFG was modified correctly.
    #  We only inspect `tmp` which now has to be between the two maps.
    assert state.in_degree(tmp) == 1
    assert state.out_degree(tmp) == 1
    top_node = next(iter(state.in_edges(tmp))).src
    bottom_node = next(iter(state.out_edges(tmp))).dst
    assert isinstance(top_node, dace_nodes.MapEntry)
    assert isinstance(bottom_node, dace_nodes.MapEntry)
    assert bottom_node is not top_node

    c[:] = 0
    sdfg(a=a, b=b, c=c, N=N, M=M)
    assert np.allclose(ref, c)
