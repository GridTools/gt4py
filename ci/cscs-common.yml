#
# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2024, ETH Zurich
# All rights reserved.
#
# Please, refer to the LICENSE file in the root directory.
# SPDX-License-Identifier: BSD-3-Clause
#

include:
  - remote: 'https://gitlab.com/cscs-ci/recipes/-/raw/master/templates/v2/.ci-ext.yml'
  - local: 'ci/cscs-ci-ext-config.yml'

variables:  # Default values for base variables (can be overriden in jobs definitions)
  CUDA_VERSION: '12.6.2'
  ROCM_VERSION: '6.2.4'
  UBUNTU_VERSION: '24.04'
  UV_VERSION: '0.6.12'

stages:
  - build
  - test

.build_base_common:
  stage: build
  # Default variables for base image builds
  variables:
    BASE_IMAGE: docker.io/ubuntu:${UBUNTU_VERSION}
    # CSCS_REBUILD_POLICY: 'always' => rebuild even if target tag exists already
    # (if-not-exists is the default, i.e. we could also skip the variable)
    CSCS_REBUILD_POLICY: if-not-exists
    DOCKERFILE: ci/Dockerfile
    DOCKER_BUILD_ARGS: >
      '[ "BASE_IMAGE=${BASE_IMAGE}",
         "CACHE_DIR=${CACHE_DIR}",
         "EXTRA_APTGET=${EXTRA_APTGET}",
         "EXTRA_UV_ENV_VARS=${EXTRA_UV_ENV_VARS}",
         "EXTRA_UV_PIP_ARGS=${EXTRA_UV_PIP_ARGS}",
         "EXTRA_UV_SYNC_ARGS=${EXTRA_UV_SYNC_ARGS}",
         "GT4PY_REPO=${GT4PY_REPO}",
         "PY_VERSION=${PY_VERSION}",
         "UV_VERSION=${UV_VERSION}",
         "WORKDIR_PATH=${WORKDIR_PATH}" ]'
  before_script:
    # We create a tag that depends on the SHA value of ci/base.Dockerfile,
    # the docker build arguments (since we use a parameterized Docker file),
    # and the contents of the `uv.lock` file (which contains the version of
    # python packages used in the base image).
    # This way a new base image is only built if the contents  of these files
    # and build arguments changes.
    - DOCKER_TAG=`echo "$(cat ${DOCKERFILE}) ${DOCKER_BUILD_ARGS} $(cat uv.lock)" | sha256sum | head -c 16`
    - export PERSIST_IMAGE_NAME=${CSCS_REGISTRY_PATH}/public/${ARCH}/base/gt4py-ci:${DOCKER_TAG}
    - echo "BASE_IMAGE=${PERSIST_IMAGE_NAME}" >> build.env
  after_script:
    # Get the name of the git target branch
    - echo "CI_COMMIT_BRANCH=${CI_COMMIT_BRANCH}"
    - export GITHUB_PR="${CI_COMMIT_BRANCH#__CSCSCI__pr}"
    - echo "GITHUB_PR=${GITHUB_PR}"
    - export GIT_TARGET_BRANCH="$(curl https://api.github.com/repos/gridtools/gt4py/pulls/${GITHUB_PR} 2>/dev/null | jq -r '.base.ref')"
    - echo GIT_TARGET_BRANCH=${GIT_TARGET_BRANCH}
    # Fetch the target branch from github
    - git remote add gh https://github.com/gridtools/gt4py
    - git fetch gh "${GIT_TARGET_BRANCH}"
    - git branch -v
    # Install script helpers: uv, yq
    - curl -LsSf https://astral.sh/uv/install.sh | sh
    - export YQ_BINARY="yq_$(uname -s | tr '[:upper:]' '[:lower:]')_$(uname -m | sed -e 's/x86_64/amd64/' | sed -e 's/aarch64/arm64/')"
    - export YQ_VERSION="v4.45.4"
    - curl https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/${YQ_BINARY} -o ${HOME}/.local/bin/yq && chmod +x ${HOME}/.local/bin/yq
    - chmod +x ${HOME}/.local/bin/yq
    - export PATH="$HOME/.local/bin:${PATH}"
    # Run script to generate the test matrix
    - ./scripts-cli.py cscs-ci matrix --verbose --base "gh/${GIT_TARGET_BRANCH}" --config nox-sessions-config.yml --output gitlab-test-matrix.yml
    - cat gitlab-test-matrix.yml
    # Insert the test matrix into the template
    - cat ci/cscs-test-template.yml
    - yq eval '.".test_matrix_job".parallel.matrix  = load("gitlab-test-matrix.yml")' ci/cscs-test-template.yml > generated_cscs_test_pipeline.yml
    - ls -las generated_cscs_test_pipeline.yml
    - cat generated_cscs_test_pipeline.yml
    # Rename the template job to the actual job name
    - export OLD_RUNNER_KEY=".${RUNNER_KEY}-template"
    - yq eval -i '(.[strenv(OLD_RUNNER_KEY)] | key) = strenv(RUNNER_KEY)' generated_cscs_test_pipeline.yml
    - ls -las generated_cscs_test_pipeline.yml
    - cat generated_cscs_test_pipeline.yml
    - echo "generated_cscs_test_pipeline=$(cat generated_cscs_test_pipeline.yml)"
  artifacts:
    # Since the base image name becomes runtime dependent, we need to carry the
    # value of it to the following jobs via the 'build.env' dotenv file.
    reports:
      dotenv: build.env
    paths:
      - generated_cscs_test_pipeline.yml

.build_with_cuda_extra:
  variables:
    BASE_IMAGE: docker.io/nvidia/cuda:${CUDA_VERSION}-devel-ubuntu${UBUNTU_VERSION}
    EXTRA_UV_SYNC_ARGS: "--extra cuda12"

.build_with_rocm_extra:
  variables:
    BASE_IMAGE: docker.io/rocm/dev-ubuntu-${UBUNTU_VERSION}:${ROCM_VERSION}-complete
    #EXTRA_UV_SYNC_ARGS: "--extra rocm6_0"
    EXTRA_UV_PIP_ARGS: ""
    EXTRA_UV_ENV_VARS: "CUPY_INSTALL_USE_HIP=1 HCC_AMDGPU_TARGET=gfx90a"


.test_trigger_base:
  stage: test
  trigger:
    strategy: depend
    forward:
      pipeline_variables: true


.test_base:
  stage: test
  #image: $CSCS_REGISTRY_PATH/public/$ARCH/gt4py/gt4py-ci:$CI_COMMIT_SHA-$PY_VERSION
  image: ${BASE_GT4PY_IMAGE}
  script:
    - cd /workspace/gt4py
    # SESSION_NAME, SESSION_ARGS and SESSION_PYTHON are set in the actual job
    - nox -s "${SESSION_NAME}-${SESSION_PYTHON}(${SESSION_ARGS})"
  variables:
    CSCS_CUDA_MPS: 1
    SLURM_JOB_NUM_NODES: 1
    SLURM_TIMELIMIT: 20
