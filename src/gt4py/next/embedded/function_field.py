# GT4Py - GridTools Framework
#
# Copyright (c) 2014-2023, ETH Zurich
# All rights reserved.
#
# This file is part of the GT4Py project and the GridTools framework.
# GT4Py is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or any later
# version. See the LICENSE.txt file at the top-level directory of this
# distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

from __future__ import annotations

import dataclasses
import inspect
import operator
from typing import Any, Callable, TypeGuard, overload

import numpy as np

from gt4py._core import definitions as core_defs
from gt4py.next import common
from gt4py.next.embedded import (
    common as embedded_common,
    exceptions as embedded_exceptions,
    nd_array_field as nd,
)
from gt4py.next.ffront import fbuiltins


@dataclasses.dataclass(frozen=True)
class FunctionField(common.FieldBuiltinFuncRegistry, common.Field[common.DimsT, core_defs.ScalarT]):
    """A `FunctionField` represents a field of values generated by a callable function over a specified domain.

    The function supplied to the `func` parameter will be used to create the ndarray when accessing
    the `ndarray` property. The result of calling `ndarray` will be the same as using
    `np.fromfunction` with the provided function.

    Args:
        func (Callable): The callable function that generates field values.
        domain (common.Domain, optional): The domain over which the function is defined.
            Defaults to an empty domain.

    Examples:
        Create a FunctionField and compute its ndarray:

        >>> import numpy as np
        >>> from gt4py.next import common
        >>> from gt4py.next.embedded.function_field import FunctionField
        >>> I = common.Dimension("I")
        >>> domain = common.Domain((I, common.UnitRange(0, 5)))
        >>> func = lambda i: i ** 2
        >>> field = FunctionField(func, domain)
        >>> ndarray = field.ndarray
        >>> expected_ndarray = np.fromfunction(func, (5,))
        >>> np.array_equal(ndarray, expected_ndarray)
        True
    """

    func: Callable
    domain: common.Domain = common.Domain()

    def __post_init__(self):
        if not callable(self.func):
            raise embedded_exceptions.FunctionFieldError(
                self.__class__.__name__,
                f"Invalid first argument type: Expected a function but got {self.func}",
            )

        if __debug__:
            try:
                self._trigger_func()
            except Exception:
                params = _get_params(self.func)
                raise embedded_exceptions.FunctionFieldError(
                    self.__class__.__name__,
                    f"Invariant violation: len(self.domain) ({len(self.domain)}) does not match the number of parameters of the provided function ({params})",
                )

    @property
    def __gt_dims__(self) -> tuple[common.Dimension, ...]:
        return self.domain.dims

    @property
    def __gt_origin__(self) -> tuple[int, ...]:
        return tuple(-r.start for _, r in self.domain)

    def _trigger_func(self):
        # TODO what should happen when domain is empty? test that this is fine.
        target_shape = tuple(1 for _ in range(len(self.domain)))
        return np.fromfunction(self.func, target_shape)

    @property
    def dtype(self) -> core_defs.DType[core_defs.ScalarT]:
        return core_defs.dtype(self.ndarray.dtype.type)

    def restrict(self, index: common.AnyIndexSpec) -> FunctionField:
        new_domain = embedded_common.sub_domain(self.domain, index)
        return self.__class__(self.func, new_domain)

    __getitem__ = restrict

    def asnumpy(self) -> core_defs.NDArrayObject:
        # handle case where we have a constant FunctionField where field.ndarray is a scalar
        if (
            isinstance(self._trigger_func(), (int, float)) and not self.domain.is_finite()
        ):  # TODO cover all relevant types if this code path still makes sense
            return np.full(tuple(1 for _ in self.domain.shape), self.func())

        if not self.domain.is_finite():
            raise embedded_exceptions.InfiniteRangeNdarrayError(
                self.__class__.__name__, self.domain
            )
        return np.fromfunction(self.func, self.domain.shape)

    @property
    def ndarray(self) -> core_defs.NDArrayObject:
        return self.asnumpy()

    def _handle_function_field_op(self, other: FunctionField, op: Callable) -> FunctionField:
        domain_intersection = self.domain & other.domain
        broadcasted_self = _broadcast(self, domain_intersection.dims)
        broadcasted_other = _broadcast(other, domain_intersection.dims)
        return self.__class__(
            _compose(op, broadcasted_self, broadcasted_other),
            domain_intersection,
        )

    def _handle_scalar_op(self, other: FunctionField, op: Callable) -> FunctionField:
        def new_func(*args):
            return op(self.func(*args), other)

        return self.__class__(
            new_func, self.domain
        )  # skip invariant as we cannot deduce number of args

    @overload
    def _binary_operation(self, op: Callable, other: core_defs.ScalarT) -> common.Field:
        ...

    @overload
    def _binary_operation(self, op: Callable, other: common.Field) -> common.Field:
        ...

    def _binary_operation(self, op, other):
        if isinstance(other, self.__class__):
            return self._handle_function_field_op(other, op)
        elif isinstance(other, (int, float)):
            return self._handle_scalar_op(other, op)
        else:
            return op(other, self)

    def _unary_op(self, op: Callable) -> FunctionField:
        return self.__class__(_compose(op, self), self.domain)

    def __ne__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return NotImplemented  # TODO

    def __add__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.add, other)

    def __sub__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.sub, other)

    def __mul__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.mul, other)

    def __truediv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.truediv, other)

    def __floordiv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.floordiv, other)

    def __mod__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.mod, other)

    __rmod__ = __mod__

    def __pow__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.pow, other)

    def __lt__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.lt, other)

    def __le__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.le, other)

    def __gt__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.gt, other)

    def __ge__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.ge, other)

    def __and__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.and_, other)

    __rand__ = __and__

    def __or__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.or_, other)

    __ror__ = __or__

    def __xor__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(operator.xor, other)

    __rxor__ = __xor__

    def __radd__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y + x, other)

    def __rfloordiv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y // x, other)

    def __rmul__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y * x, other)

    def __rsub__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y - x, other)

    def __rtruediv__(self, other: common.Field | core_defs.ScalarT) -> common.Field:
        return self._binary_operation(lambda x, y: y / x, other)

    def __pos__(self) -> common.Field:
        return self._unary_op(operator.pos)

    def __neg__(self) -> common.Field:
        return self._unary_op(operator.neg)

    def __abs__(self) -> common.Field:
        return self._unary_op(abs)

    def __invert__(self) -> common.Field:
        if self.dtype == core_defs.BoolDType():
            return self._unary_op(operator.invert)
        raise NotImplementedError("`__invert__` not implemented for non-`bool` fields.")

    def __call__(self, *args, **kwargs) -> common.Field:
        return self.func(*args, **kwargs)

    def remap(self, *args, **kwargs) -> common.Field:
        raise NotImplementedError("Method remap not implemented")


def _compose(operation: Callable, *fields: FunctionField) -> Callable:
    return lambda *args: operation(*[f.func(*args) for f in fields])


def _broadcast(field: FunctionField, dims: tuple[common.Dimension, ...]) -> FunctionField:
    def broadcasted_func(*args: int | core_defs.NDArrayObject):
        selected_args = [args[i] for i, dim in enumerate(dims) if dim in field.domain.dims]
        return field.func(*selected_args)

    named_ranges = embedded_common.broadcast_domain(field, dims)
    return FunctionField(broadcasted_func, common.Domain(*named_ranges))


def _is_nd_array(other: Any) -> TypeGuard[nd._BaseNdArrayField]:
    return isinstance(other, nd._BaseNdArrayField)


def constant_field(
    value: core_defs.ScalarT, domain: common.Domain = common.Domain()
) -> common.Field:
    return FunctionField(lambda *args: value, domain)


def _compose_function_field_with_builtin(builtin_name: str) -> Callable:
    def _composed_function_field(field: FunctionField) -> FunctionField:
        if builtin_name not in _UNARY_BUILTINS:
            raise ValueError(f"Unsupported built-in function: {builtin_name}")

        if builtin_name in ["abs", "power", "gamma"]:
            return field

        builtin_func = getattr(np, builtin_name)

        def new_func(*args):
            return builtin_func(field.func(*args))

        new_field: FunctionField = FunctionField(new_func, field.domain)
        return new_field

    return _composed_function_field


FunctionField.register_builtin_func(fbuiltins.broadcast, _broadcast)

_UNARY_BUILTINS = (
    fbuiltins.UNARY_MATH_FP_BUILTIN_NAMES
    + fbuiltins.UNARY_MATH_FP_PREDICATE_BUILTIN_NAMES
    + fbuiltins.UNARY_MATH_NUMBER_BUILTIN_NAMES
)

for builtin_name in _UNARY_BUILTINS:
    if builtin_name in ["abs", "gamma"]:
        continue
    FunctionField.register_builtin_func(
        getattr(fbuiltins, builtin_name), _compose_function_field_with_builtin(builtin_name)
    )

FunctionField.register_builtin_func(fbuiltins.abs, FunctionField.__abs__)  # type: ignore[attr-defined]


def _get_params(func: Callable) -> str:
    """Pretty print callable parameters."""
    signature = inspect.signature(func)
    parameters = signature.parameters
    param_strings = [f"{name}: {param}" for name, param in parameters.items()]
    formatted_params = ", ".join(param_strings)
    return formatted_params
