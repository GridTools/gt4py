{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2019, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - api_names: [str]
    - arg_fields: [{ "name": str, "dtype": str, "layout_id": int, "selector": [bool], "naxes": int }]
    - gt_backend: str
    - module_name: str
    - parameters: [{ "name": str, "dtype": str }]
    - stencil_unique_name: str
#}

#include "computation.hpp"

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include <vector>
#include <chrono>

#include "numpy/ndarraytypes.h"

namespace py = ::pybind11;

static constexpr int MAX_DIM = 3;

namespace {

BufferInfo make_buffer_info(const py::capsule& buffer_as_capsule) {
    PyArrayInterface* b = buffer_as_capsule.cast<py::capsule>();
    return BufferInfo{b->nd, b->shape, b->strides, b->data};
}

void run_computation(const std::array<gt::uint_t, MAX_DIM>& domain,
{%- set comma = joiner(", ") -%}
{%- for api_name in api_names -%}
{%- for field in arg_fields -%}
{%- if api_name == field.name -%}
                     {{- comma() }}
                     const py::capsule& {{ field.name }}_capsule, const std::array<gt::uint_t, {{ field.naxes }}>& {{ field.name }}_origin
{%- endif -%}
{%- endfor -%}
{%- for param in parameters -%}
{%- if api_name == param.name -%}
                     {{- comma() }}
                     {{ param.dtype }} {{ param.name }}
{%- endif -%}
{%- endfor -%}
{%- endfor -%}, py::object& exec_info)
{
    if (!exec_info.is(py::none()))
    {
        auto exec_info_dict = exec_info.cast<py::dict>();
        exec_info_dict["run_cpp_start_time"] = static_cast<double>(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count())/1e9;
    }

{%- for field in arg_fields %}
    auto bi_{{ field.name }} = make_buffer_info({{ field.name }}_capsule);
{%- endfor %}

    {{ stencil_unique_name }}::run(domain,
{%- set comma = joiner(", ") -%}
{%- for field in arg_fields -%}
        {{- comma() }}
        bi_{{ field.name }}, {{ field.name }}_origin
{%- endfor -%}
{%- for param in parameters -%}
        {{- comma() }}
        {{ param.name }}
{%- endfor %});

    if (!exec_info.is(py::none()))
    {
        auto exec_info_dict = exec_info.cast<py::dict>();
        exec_info_dict["run_cpp_end_time"] = static_cast<double>(std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::high_resolution_clock::now().time_since_epoch()).count()/1e9);
    }
}

}  // namespace


PYBIND11_MODULE({{ module_name }}, m) {
    m.def("run_computation", &run_computation, "Runs the given computation",
          py::arg("domain"),
{%- set comma = joiner(", ") -%}
{%- for api_name in api_names -%}
{%- for field in arg_fields -%}
{%- if api_name == field.name -%}
          {{- comma() }}
          py::arg("{{ field.name }}") {{- comma() }} py::arg("{{ field.name }}_origin") {{- zero_origin }}
{%- endif -%}
{%- endfor -%}
{%- for param in parameters -%}
{%- if api_name == param.name -%}
          {{- comma() }}
          py::arg("{{ param.name }}")
{%- endif -%}
{%- endfor -%}
{%- endfor -%}, py::arg("exec_info"));

}
