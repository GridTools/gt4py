{#

 # GT4Py - GridTools4Py - GridTools for Python
 #
 # Copyright (c) 2014-2019, ETH Zurich
 # All rights reserved.
 #
 # This file is part the GT4Py project and the GridTools framework.
 # GT4Py is free software: you can redistribute it and/or modify it under
 # the terms of the GNU General Public License as published by the
 # Free Software Foundation, either version 3 of the License, or any later
 # version. See the LICENSE.txt file at the top-level directory of this
 # distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
 #
 # SPDX-License-Identifier: GPL-3.0-or-later

 ---- Template variables ----

    - arg_fields: [{ "name": str, "dtype": str, "size": int, "origin": [int, int, int], "shape": [int, int, int], "stride": [int, int, int] }]
    - domain: [int, int, int]
    - parameters: [{ "name": str, "dtype": str, "value": str }]
    - out_fields: [{ "name": str, "dtype": str, "size": int }]
    - stencil_short_name: str
    - stencil_unique_name: str
    - test_path: str
    - backend: str
#}
#include "computation.hpp"

#include <cmath>
#include <fstream>
#include <memory>
#include <string>
#include <vector>
#include <chrono>

{%- if "cuda" in backend %}
#include <cuda.h>
#include <cuda_runtime.h>
{%- endif %}
#include <gtest/gtest.h>

namespace {{ stencil_unique_name }}_pyext {

typedef float float32;
typedef double float64;

const float32 float32_precision = 1e-6;
const float64 float64_precision = 1e-10;
const std::string test_path = "{{ test_path }}/";

template <typename T>
bool compare_values(T expected, T actual, T precision) {
  if(!std::isnan(actual)) {
    if(std::fabs(expected) < 1e-3 && std::fabs(actual) < 1e-3) {
      if(std::fabs(expected - actual) < precision)
        return true;
    } else {
      if(std::fabs((expected - actual) / (precision * expected)) < 1.0)
        return true;
    }
  }
  return false;
}

template <typename T>
std::unique_ptr<std::vector<T>> read_csv(const std::string& csv_file) {
  auto data = std::unique_ptr<std::vector<T>>(new std::vector<T>{});
  std::fstream fin(csv_file, std::ios::in);
  if(fin.is_open()) {
    std::string line;
    while (std::getline(fin, line, ',')) {
      data->push_back(std::stod(line));
    }
  }
  return data;
}

template <typename T, unsigned N>
void write_csv(const std::string& csv_file, const std::unique_ptr<std::array<T, N>>& data) {
  std::ofstream fout(csv_file);
  if(fout.is_open()) {
    fout.precision(18);
    for(int i = 0; i < N; ++i) {
      fout << std::scientific << data->at(i);
      if(i < N - 1)
        fout << ",";
    }
    fout << "\n";
  }
}

TEST(TestGT4Py, {{ stencil_short_name }}) {
  std::array<unsigned, 3> domain{ {{ domain[0] }}, {{ domain[1] }}, {{ domain[2] }} };
{% for field in arg_fields -%}
  std::array<unsigned, 3> {{ field.name }}_origin{ {{ field.origin[0] }}, {{ field.origin[1] }}, {{ field.origin[2] }} };
{% endfor -%}


{% for param in parameters -%}
  {{ param.dtype }} {{ param.name }} = {{ param.value }};
{% endfor -%}


{% for field in arg_fields -%}
  std::unique_ptr<std::array<{{ field.dtype }}, {{ field.size }}>> {{ field.name }}(new std::array<{{ field.dtype }}, {{ field.size }}>{
  #include "data/{{ field.name }}.csv"
  });
{% endfor -%}


{%- if "cuda" in backend %}
{% for field in arg_fields -%}
  {{ field.dtype }}* d_{{ field.name }};
  cudaMalloc((void**) &d_{{ field.name }}, {{ field.size }} * sizeof({{ field.dtype }}));
  cudaMemcpy(d_{{ field.name }}, {{ field.name }}->data(), {{ field.size }} * sizeof({{ field.dtype }}), cudaMemcpyHostToDevice);
{% endfor -%}
{%- endif %}

{%- if "cuda" in backend %}
{% for field in arg_fields -%}
  auto bi_{{ field.name }} = BufferInfo{3, { {{ field.shape[0] }}, {{ field.shape[1] }}, {{ field.shape[2] }} }, { {{ field.stride[0] }}, {{ field.stride[1] }}, {{ field.stride[2] }} }, d_{{ field.name }}};
{% endfor -%}
{%- else %}
{% for field in arg_fields -%}
  auto bi_{{ field.name }} = BufferInfo{3, { {{ field.shape[0] }}, {{ field.shape[1] }}, {{ field.shape[2] }} }, { {{ field.stride[0] }}, {{ field.stride[1] }}, {{ field.stride[2] }} }, {{ field.name }}->data()};
{% endfor -%}
{%- endif %}

  double start_run_time =
      static_cast<double>(
          std::chrono::duration_cast<std::chrono::nanoseconds>(
              std::chrono::high_resolution_clock::now().time_since_epoch())
              .count()) * 1e-9;

  run(domain,
{%- set comma = joiner(", ") -%}
{%- for field in arg_fields -%}
      {{- comma() }}
      bi_{{ field.name }}, {{ field.name }}_origin
{%- endfor -%}
{%- for param in parameters -%}
      {{- comma() }}
      {{ param.name }}
{%- endfor %});

  double end_run_time = static_cast<double>(
      std::chrono::duration_cast<std::chrono::nanoseconds>(
          std::chrono::high_resolution_clock::now().time_since_epoch())
          .count() * 1e-9);


{%- if "cuda" in backend %}
{% for field in out_fields -%}
cudaMemcpy({{ field.name }}->data(), d_{{ field.name }}, {{ field.size }} * sizeof({{ field.dtype }}), cudaMemcpyDeviceToHost);
{% endfor -%}

{% for field in arg_fields -%}
  cudaFree(d_{{ field.name }});
{% endfor -%}
{%- endif %}

{% for field in out_fields -%}
  auto {{ field.name }}_out = read_csv<{{ field.dtype }}>(test_path + "data/{{ field.name }}_out.csv");
  if(!{{ field.name }}_out->empty()) {
    ASSERT_EQ({{ field.name }}->size(), {{ field.name }}_out->size());
    {% for arg_field in arg_fields -%}
    {% if field.name == arg_field.name -%}
    std::array<unsigned, 3> data_strides = { {{ arg_field.stride[0] }} / sizeof({{ arg_field.dtype }}), {{ arg_field.stride[1] }} / sizeof({{ arg_field.dtype }}),
                                             {{ arg_field.stride[2] }} / sizeof({{ arg_field.dtype }}) };
    {% endif -%}
    {% endfor -%}
    for(int i = {{ field.name }}_origin[0]; i < domain[0] + {{ field.name }}_origin[0]; ++i) {
      for(int j = {{ field.name }}_origin[1]; j < domain[1] + {{ field.name }}_origin[1]; ++j) {
        for(int k = {{ field.name }}_origin[2]; k < domain[2] + {{ field.name }}_origin[2]; ++k) {
          int idx = i * data_strides[0] + j * data_strides[1] + k * data_strides[2];
      bool matched = compare_values<{{ field.dtype }}>({{ field.name }}_out->at(idx), {{ field.name }}->at(idx),
                                    {{ field.dtype }}_precision);
      if(!matched)
        write_csv<{{ field.dtype }}, {{ field.size }}>(test_path + "data/{{ field.name }}_fail.csv", {{ field.name }});
      ASSERT_TRUE(matched)  << {{ field.name }}_out->at(idx) << " !~ " << {{ field.name }}->at(idx)
                            << " at (" << i << "," << j << "," << k << ")";
    } } }
  }
{% endfor -%}

  std::cout << "{{ stencil_short_name }} run_time: "
            << end_run_time - start_run_time << std::endl;

  SUCCEED();
} // TestGT4Py_{{ stencil_short_name }}

#ifndef _GTEST_MAIN_
int main(int argc, char* argv[]) {
  // Initialize GTest
  testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
} // main
#define _GTEST_MAIN_
#endif

} // namespace {{ stencil_unique_name }}_pyext
