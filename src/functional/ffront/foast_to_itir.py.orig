# GT4Py Project - GridTools Framework
#
# Copyright (c) 2014-2021, ETH Zurich
# All rights reserved.
#
# This file is part of the GT4Py project and the GridTools framework.
# GT4Py is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or any later
# version. See the LICENSE.txt file at the top-level directory of this
# distribution for a copy of the license or check <https://www.gnu.org/licenses/>.
#
# SPDX-License-Identifier: GPL-3.0-or-later

<<<<<<< HEAD
from ast import Expr, NodeTransformer
from typing import Iterator, Optional, Union

import factory

from eve import NodeTranslator
from eve.visitors import NodeVisitor
import functional
from functional.ffront import common_types
=======
from typing import Optional

from eve import NodeTranslator
>>>>>>> functional
from functional.ffront import field_operator_ast as foast
from functional.ffront import itir_makers as im
from functional.ffront.type_info import TypeInfo
from functional.iterator import ir as itir
from functional.ffront.fbuiltins import FUN_BUILTIN_NAMES
from collections import namedtuple

FieldAccess = namedtuple("FieldAccess", ["name", "shift"])


<<<<<<< HEAD
class AssignResolver(NodeTranslator):
    """
    Inline a sequence of assignments into a final return statement.

    >>> from functional.ffront.func_to_foast import FieldOperatorParser
    >>> from functional.common import Field
    >>>
    >>> float64 = float
    >>>
    >>> def fieldop(inp: Field[..., "float64"]):
    ...     tmp1 = inp
    ...     tmp2 = tmp1
    ...     return tmp2
    >>>
    >>> fieldop_foast_expr = AssignResolver.apply(FieldOperatorParser.apply_to_function(fieldop).body)
    >>> fieldop_foast_expr  # doctest: +ELLIPSIS
    Return(location=..., value=Name(location=..., id='inp'))
    """

    @classmethod
    def apply(
        cls, nodes: list[foast.Expr], *, params: Optional[list[itir.Sym]] = None
    ) -> foast.Expr:
        names: dict[str, foast.Expr] = {}
        parser = cls()
        for node in nodes[:-1]:
            names.update(parser.visit(node, names=names))
        return foast.Return(
            value=parser.visit(nodes[-1].value, names=names), location=nodes[-1].location
        )

    def visit_Assign(
        self,
        node: foast.Assign,
        *,
        names: Optional[dict[str, foast.Expr]] = None,
    ) -> dict[str, itir.Expr]:
        return {node.target.id: self.visit(node.value, names=names)}

    def visit_Name(
        self,
        node: foast.Name,
        *,
        names: Optional[dict[str, foast.Expr]] = None,
    ):
        names = names or {}
        if node.id in names:
            return names[node.id]
        return node


class FieldCollector(NodeVisitor):
    def __init__(self):
        self._fields = set()
        self.in_shift = False

    def visit_FunCall(self, node: itir.FunCall, **kwargs) -> None:
        if isinstance(node.fun, itir.FunCall) and node.fun.fun.id == "shift":
            self._fields.add(FieldAccess(node.args[0].id, node.fun.args[0]))
        else:
            self.generic_visit(node)

    def visit_SymRef(self, node: itir.SymRef, **kwargs) -> None:
        if not hasattr(functional.iterator.builtins, node.id):
            self._fields.add(FieldAccess(node.id, None))

    def getFields(self):
        return list(sorted(self._fields))


class DerefRemover(NodeTranslator):
    def visit_FunCall(self, node: itir.FunCall) -> itir.FunCall:
        if isinstance(node.fun, itir.FunCall):
            new_args = self.visit(node.args)
            return itir.FunCall(fun=node.fun, args=new_args)

        if node.fun.id == "deref":
            return node.args[0]

        new_args = self.visit(node.args)
        return itir.FunCall(fun=node.fun, args=new_args)


class ShiftRemover(NodeTranslator):
    def visit_FunCall(self, node: itir.FunCall) -> itir.FunCall:
        if isinstance(node.fun, itir.FunCall) and node.fun.fun.id == "shift":
            return itir.SymRef(id=node.args[0].id)
        new_args = self.visit(node.args)
        return itir.FunCall(fun=node.fun, args=new_args)


class SymRefRenamer(NodeTranslator):
    def __init__(self, suffix: str):
        self.suffix = suffix

    def visit_SymRef(self, node: itir.SymRef):
        if not hasattr(functional.iterator.builtins, node.id):
            return itir.SymRef(id=node.id + self.suffix)
        return node


class ItirSymRefFactory(factory.Factory):
    class Meta:
        model = itir.SymRef


class ItirFunCallFactory(factory.Factory):
    """
    Readability enhancing shortcut for itir.FunCall constructor.

    Usage:
    ------

    >>> ItirFunCallFactory(name="plus")
    FunCall(fun=SymRef(id='plus'), args=[])
    """

    class Meta:
        model = itir.FunCall

    class Params:
        name: Optional[str] = None

    fun = factory.LazyAttribute(lambda obj: ItirSymRefFactory(id=obj.name))
    args = factory.List([])


class ItirDerefFactory(ItirFunCallFactory):
    """Readability enhancing shortcut constructing deref itir builtins."""

    class Params:
        name = "deref"


class ItirShiftFactory(ItirFunCallFactory):
    """Readability enhancing shortcut constructing shift itir builtins."""

    class Params:
        name = "shift"
        shift_args: list[Union[itir.OffsetLiteral, itir.IntLiteral]] = []

    fun = factory.LazyAttribute(lambda obj: ItirFunCallFactory(name=obj.name, args=obj.shift_args))


def _name_is_field(name: foast.Name) -> bool:
    return isinstance(name.type, common_types.FieldType)


=======
>>>>>>> functional
class FieldOperatorLowering(NodeTranslator):
    """
    Lower FieldOperator AST (FOAST) to Iterator IR (ITIR).

    Examples
    --------
    >>> from functional.ffront.func_to_foast import FieldOperatorParser
    >>> from functional.common import Field
    >>>
    >>> float64 = float
    >>>
    >>> def fieldop(inp: Field[..., "float64"]):
    ...    return inp
    >>>
    >>> parsed = FieldOperatorParser.apply_to_function(fieldop)
    >>> lowered = FieldOperatorLowering.apply(parsed)
    >>> type(lowered)
    <class 'functional.iterator.ir.FunctionDefinition'>
    >>> lowered.id
    'fieldop'
    >>> lowered.params
    [Sym(id='inp')]
    """

    class lifted_lambda:
        def __init__(self, *params):
            self.params = params

        def __call__(self, expr):
            return im.lift_(im.lambda__(*self.params)(expr))(*self.params)

    @classmethod
    def apply(cls, node: foast.FieldOperator) -> itir.FunctionDefinition:
        return cls().visit(node)

    def visit_FieldOperator(self, node: foast.FieldOperator, **kwargs) -> itir.FunctionDefinition:
        symtable = node.symtable_
        params = self.visit(node.params, symtable=symtable)
        return itir.FunctionDefinition(
            id=node.id,
            params=params,
            expr=self._visit_body(node.body, params=params, symtable=symtable),
        )

    def _visit_body(
        self, body: list[foast.Stmt], params: Optional[list[itir.Sym]] = None, **kwargs
    ) -> itir.FunCall:
        *assigns, return_stmt = body
        current_expr = self.visit(return_stmt, **kwargs)

        for assign in reversed(assigns):
            current_expr = im.let(*self._visit_assign(assign, **kwargs))(current_expr)

        return im.deref_(current_expr)

    def _visit_assign(self, node: foast.Assign, **kwargs) -> tuple[itir.Sym, itir.Expr]:
        sym = self.visit(node.target, **kwargs)
        expr = self.visit(node.value, **kwargs)
        return sym, expr

    def visit_Return(self, node: foast.Return, **kwargs) -> itir.Expr:
        return self.visit(node.value)

    def visit_Symbol(self, node: foast.Symbol, **kwargs) -> itir.Sym:
        return im.sym(node.id)

    def visit_Name(self, node: foast.Name, **kwargs) -> itir.SymRef:
        return im.ref(node.id)

    def _lift_lambda(self, node):
        def is_field(expr: foast.Expr) -> bool:
            return TypeInfo(expr.type).is_field_type

        param_names = list(
            node.iter_tree().if_isinstance(foast.Name).filter(is_field).getattr("id").unique()
        )
        return self.lifted_lambda(*param_names)

    def visit_Subscript(self, node: foast.Subscript, **kwargs) -> itir.FunCall:
        return im.tuple_get_(node.index, self.visit(node.value, **kwargs))

    def visit_TupleExpr(self, node: foast.TupleExpr, **kwargs) -> itir.FunCall:
        return im.make_tuple_(*self.visit(node.elts, **kwargs))

    def visit_UnaryOp(self, node: foast.UnaryOp, **kwargs) -> itir.FunCall:
        # TODO(tehrengruber): extend iterator ir to support unary operators
        zero_arg = [itir.IntLiteral(value=0)] if node.op is not foast.UnaryOperator.NOT else []
        return self._lift_lambda(node)(
            im.call_(node.op.value)(*[*zero_arg, im.deref_(self.visit(node.operand, **kwargs))])
        )

    def visit_BinOp(self, node: foast.BinOp, **kwargs) -> itir.FunCall:
        return self._lift_lambda(node)(
            im.call_(node.op.value)(
                im.deref_(self.visit(node.left, **kwargs)),
                im.deref_(self.visit(node.right, **kwargs)),
            )
        )

    def visit_Compare(self, node: foast.Compare, **kwargs) -> itir.FunCall:
        return self._lift_lambda(node)(
            im.call_(node.op.value)(
                im.deref_(self.visit(node.left, **kwargs)),
                im.deref_(self.visit(node.right, **kwargs)),
            )
        )

<<<<<<< HEAD
    def visit_Shift(self, node: foast.Shift, **kwargs) -> itir.Expr:
        shift_args = list(self._gen_shift_args(node.offsets))
        return self.visit(node.expr, shift_args=shift_args, **kwargs)

    def _make_shift_args(
        self, node: Union[foast.Subscript, foast.Name], **kwargs
    ) -> Union[tuple[itir.OffsetLiteral, itir.IntLiteral], tuple[itir.OffsetLiteral]]:
        if isinstance(node, foast.Subscript):
            return (itir.OffsetLiteral(value=node.value.id), itir.IntLiteral(value=node.index))
        else:
            return (itir.OffsetLiteral(value=node.id),)

    def _gen_shift_args(
        self, args: list[Union[foast.Subscript, foast.Name]], **kwargs
    ) -> Iterator[Union[itir.OffsetLiteral, itir.IntLiteral]]:
        for arg in args:
            yield from self._make_shift_args(arg)

    def _extract_fields(self, expr: itir.Expr) -> list[str]:
        fc = FieldCollector()
        fc.visit(expr)
        return fc.getFields()

    def _remove_field_shifts(self, expr: itir.Expr) -> itir.Expr:
        sr = ShiftRemover()
        expr = sr.visit(expr)
        return expr

    def _remove_field_derefs(self, expr: itir.Expr) -> itir.Expr:
        dr = DerefRemover()
        expr = dr.visit(expr)
        return expr

    def _rename_sym_refs(self, expr: itir.Expr, suffix: str) -> itir.Expr:
        rn = SymRefRenamer(suffix)
        expr = rn.visit(expr)
        return expr

    def _make_lamba_rhs(self, expr: itir.Expr) -> itir.FunCall:
        return ItirFunCallFactory(name="plus", args=[itir.SymRef(id="base"), expr])

    def _make_reduce(self, *args, **kwargs) -> itir.FunCall:
        red_rhs = self.visit(args[0], **kwargs)

        # get all fields referenced (technically this could also be external symbols)
        # this assumes that the same field doesn't appear both shifted and not shifted,
        # which should be checked for before the lowering
        rhs_fields = self._extract_fields(red_rhs[0])

        # to lower the expr to the lambda expr we need to
        #   - remove derefs
        #   - remove shifts
        #   - rename the fields being accessed (I think this is not strictly
        #     needed, but improves readabiltiy)
        rhs_lambda = itir.Lambda(
            params=[itir.Sym(id="base")]
            + [itir.Sym(id=field.name + "_param") for field in rhs_fields],
            expr=self._make_lamba_rhs(
                self._rename_sym_refs(
                    self._remove_field_derefs(self._remove_field_shifts(red_rhs[0])), "_param"
                )
            ),
        )
        # the arguments passed to the lambda are either a symref to the field, or, if the
        # field is shifted in the original expr, the shifted field
        lambda_args = []
        for field in rhs_fields:
            if field.shift is not None:
                lambda_args.append(
                    ItirFunCallFactory(
                        fun=ItirFunCallFactory(name="shift", args=[field.shift]),
                        args=[itir.SymRef(id=field.name)],
                    )
                )
            else:
                lambda_args.append(itir.SymRef(id=field.name))

        reduce_call = ItirFunCallFactory(
            fun=ItirFunCallFactory(name="reduce", args=[rhs_lambda, itir.IntLiteral(value=0.0)]),
            args=lambda_args,
        )

        return reduce_call

    def visit_Call(self, node: foast.Call, **kwargs) -> itir.FunCall:
        if node.func.id in FUN_BUILTIN_NAMES:
            return self._make_reduce(node.args, **kwargs)
        new_fun = (
            itir.SymRef(id=node.func.id)
            if isinstance(node.func, foast.Name)  # name called, e.g. my_fieldop(a, b)
            else self.visit(node.func, **kwargs)  # expression called, e.g. local_op[...](a, b)
        )
        return ItirFunCallFactory(
            fun=new_fun,
            args=self.visit(node.args, **kwargs),
=======
    def _visit_shift(self, node: foast.Call, **kwargs) -> itir.FunCall:
        return im.shift_(node.args[0].value.id, node.args[0].index)(self.visit(node.func, **kwargs))

    def visit_Call(self, node: foast.Call, **kwargs) -> itir.FunCall:
        if TypeInfo(node.func.type).is_field_type:
            return self._visit_shift(node, **kwargs)
        return self._lift_lambda(node)(
            im.call_(self.visit(node.func, **kwargs))(*self.visit(node.args, **kwargs))
>>>>>>> functional
        )
