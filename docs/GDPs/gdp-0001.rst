=================================
GDP X — Template and Instructions
=================================

:Author: <Rhea George (rheag@vulcan.com), Tobias Wicky(tobiasw@vulcan.com), Johann Dahm(johannd@vulcan.com), Eddie Davis(eddied@vulca.com, Jeremy McGibbon(jeremyM@vulca.com), Mark Cheeseman(markc@vulcan.com), Oliver Elbert(olivere@vulcan.com) >
:Status: Draft
:Type: Feature
:Created: 03-27-2020
:Discussion PR: <PR url>


Abstract
--------

We propose a mechanism to enable specification of horizontal bounds of a global iteration space inside a stencil definition. This will 1) enable more potential optimization by the backend and 2) Enable expressing boundary computations adjacent to the code specifying the main compute domain calculations, which may make this library more user-friendly for domain scientists. 

Motivation and Scope
--------------------

A model over a geographic domain often has different (or additional adjustment) computations applied to the global horizontal boundaries of the domain. There may be boundary conditions to be met, or grid specific needs in certain parts of the domain. For example, in the case of the cubed-sphere grid, each of the 6 cube faces requires special handling of their edges and corners to avoid discontinuities that would otherwise cause the model to crash. Currently with GT4py we can handle such specific domain calculations by using the optional arguments of 'origin' and 'domain' when calling a stencil. This restricts the region over which calculations happen on the data arrays passed in on the local iteration space. We also need code outside of the stencil to check whether the current subdomain being operated on (due to domain decomposition/parallelization) includes the relevant boundary, and trigger calling the specialty stencils. This works for getting the right answer, but there are a couple of reasons why it would be helpful to be able to specify these inside the stencil as can be done with the vertical direction (e.g. using 'interval'), and to be able to specify global regions:

 -  Some backends would be able to optimize more effectively if more calculations are specified inside the stencil -- e.g. more fusing and automatic decisions can be made

 - With the current solution, to understand the model you need to jump back and forth between the function that calls the stencil and the separate stencils that define the main compute domain and the stencils that compute edge/corner conditions. This makes it difficult to keep track of what is happening in the model. For example, here is how a variable 'ub' that has special global edge stencils can be computed now:

.. code-block:: python

   FIELD_TYPE=gtscript.Field[np.float]​
   @gtscript.stencil(backend=backend)​
   def main_ub(uc: FIELD_TYPE, vc: FIELD_TYPE, cosa: FIELD_TYPE, rsina: FIELD_TYPE, ub: FIELD_TYPE, dt5: float):​
       with computation(PARALLEL), interval(...):​
          ub = dt5 * (uc[0, -1, 0] + uc - ​(vc[-1, 0, 0] + vc) * cosa) * rsina​

   @gtscript.stencil(backend=backend)​
   def x_edge_ub(ut: FIELD_TYPE, ub: FIELD_TYPE, dt5: float)::
      with computation(PARALLEL), interval(...):​
        ub = dt5 * (ut[0, -1, 0] + ut)​

   @gtscript.stencil(backend=backend)​
   def y_edge_ub(ut: FIELD_TYPE, ub: FIELD_TYPE, *, dt4: float):
      with computation(PARALLEL), interval(...):
         ub = dt4 * (-ut[0, -2, 0] + 3.0 * (ut[0, -1, 0] + ut) - ut[0, 1, 0])

   def compute(uc, vc, ut, ub, dt5, dt4, grid):​
      domain_y = (grid.ni, 1, grid.nz)
      domain_x = (1, grid.nj, grid.nz)
      main_ub(uc, vc, grid.cosa, grid.rsina, ub, dt5=dt5, ​
              origin=(grid.local_istart, grid.local_jstart, 0),
              domain=(grid.ni, grid.nj, grid.nz))​
      if grid.west_edge:​
         x_edge_ub(ut, ub, dt5=dt5, ​origin=(grid.local_istart, grid.local_jstart, 0), ​domain=domain_x_edge)​
      if grid.south_edge:
         y_edge(ut, ub, dt4=dt4, origin=(grid.local_istart, grid.local_jstart, 0), domain=domain_y_edge)
      if grid.north_edge:
         y_edge_ub(ut, ub, dt4=dt4, origin=(grid.local_istart, grid.local_jend, 0), domain=domain_y_edge)
      if grid.east_edge:
         x_edge_ub(ut, ub, dt5=dt5, origin=(grid.local_iend, grid.local_jstart, 0), domain=domain_x_edge)
      
   
To understand what is happening to ub, you need to flip back and forth to the different stencils, and include many conditionals checking if the local domain includes the cube face edges. And this is a relatively simple example, there are similar mechanisms for corners, and some edge calculations are applied to one or more row or column adjacent to the edge, either in the halo or in the compute domain. This also is a lot of code when you need something similar for almost every calculation, and thus obscures the main thing being accomplished --  the main_ub stencil. The user must always explicitly check -- am I on an edge? Ok, run this edge stencil. If this could be abstracted a little, it would reduce code volume and make it easier to follow.

The current method of implementing corner and edge logic impacts readability for users/developers making use of the GT4py and prevents the backend from optimizing/scheduling as well as it could (because each edge specification is in a separate blocking stencil call). Our proposal here of allowing this specification be in the stencil definition should help both of these points, as well as reduce coding errors specifying boundaries. 

Key requirements:
 - A user can specify horizontal subdomains in the global iteration space with different blocks inside a stencil
 - The specification of boundaries should ideally be flexible to specifying subregions arbitrarily, and also easy to make clean with abstraction to e.g. objects named things like WestEdge
 - If a stencil is applied to a region wider than the compute domain(into the halo, if there is a halo), it should still be easy to specify that as it is now
 - We should be able to easily operate on cells adjacent to compute domain edges/corners
 - It should be possible to specify multiple horizontal ranges for the same stencil (e.g. when the stencil is the same for both the left and the right edges of a domain, do not require duplicating the stencil)
 - It would be helpful to have a capability for offsets to global indices to be variables (could be imported externals if needed). Currently the interval() for the vertical dimension only allows hard coded values. This is a secondary request in the framework of this proposal.


Usage and Impact
----------------
​Users who want to group together a category of operations would benefit, with edge/corner handling directly adjacent within the stencil. Here is one proposed way we'd be able to represent the code above by introducing a 'boundary' keyword:

# edge abstraction specific to a model, defined once by domain scientist and reused throughout model. Perhaps gt4py provides a Box abstraction? In some way the user would be able to define e.g. WestEdge with arguments of indices relative to the compute domain 'edge' of a full tile
 - WestEdge(start, end) -> Box(slice(start + grid.global_istart, end + grid.global_istart), slice(0, None))​
 - SouthEdge(start, end) -> Box(slice(0, None), slice(start + grid.global_jstart, end + grid.global_jstart))​
 - EastEdge(start, end) -> Box(slice(start + grid.global_iend, end + grid.global_iend), slice(0, None))​
 - NorthEdge(start, end) -> Box(slice(0, None), slice(start + grid.global_jend, end + grid.global_jend))​

.. code-block:: python

  # their stencil
  @gtscript.stencil(backend="dawn:gtmc", partitioner=partitioner)
  def ubke(uc: FIELD_TYPE, vc: FIELD_TYPE, cosa: FIELD_TYPE, rsina: FIELD_TYPE, ut: FIELD_TYPE, ub: FIELD_TYPE, dt5: float, dt4: float):
    with computation(PARALLEL), interval(...): # applies to the compute domain as it does now
        ub = dt5 * (uc[0, -1, 0] + uc - (vc[-1, 0, 0] + vc) * cosa) * rsina
    with boundary((WestEdge(0, 1), EastEdge(0, 1)), interval(...):
        ub = dt5 * (ut[0, -1, 0] + ut)​
    with boundary((SouthEdge, 0, 1), (NorthEdge, 0, 1)), interval(...):
        ub = dt4 * (-ut[0, -2, 0] + 3.0 * (ut[0, -1, 0] + ut) - ut[0, 1, 0])
    
​  # calling the stencil
  def compute(uc, vc, ut, ub, dt5, dt4, grid):​
    ubke(uc, vc, grid.cosa, grid.rsina, ub, ut, dt5, dt4)

This drastically reduces the complexity of the code and consolidates operations on ub. It is readable and understandable to the user what is happening. Since they already will understand the idea of offsets with the stencil notation of e.g. uc[0, -1, 0], it is not a big leap to understand box offsets from an edge.



Backward compatibility
----------------------

This proposal includes a few suggestions, some of which maintain more backward compatibility than others -- some of the alternative solutions would alter the meaning of 'interval'. 

This proposal assumes we are operating on a domain with a main compute region and a halo region, which should be user specified. Gt4py still needs to work even if there is no such concept for the user. We are proposing an additional optional construct, which not every user will want to employ.

We do need to be careful that the implementation plays well with the existing construct of specifying 'origin' and 'domain' to restrict the horizontal compute region. Unless you decide to get rid of that in favor of generalizing the solution here for arbitrary horizontal regions specified inside the stencil. In that case, this existing option should probably be deprecated, or at least crash with a meaningful method if it is used in combination with internal horizontal specification. Or, the behavior of the two mechanisms in combination with each other needs to be clear. 


Detailed description
--------------------
We would like to specify a horizontal interval inside the stencil, similar to how a vertical interval is currently specified. However, there are a couple of factors that make this more complicated than the vertical dimension:
1) We want to specify specific stencils for edges/corners of the domain in the global iteration space, that only get applied to the appropriate subdomains when a tile edge is in the current decomposed region being operated on (e.g. at scale when tiles are split into many subdomains, some of which include the global edges and some that don't)
2) The distinction of a compute domain and a halo region needs to be easy to handle. We often want to apply computations mainly to the compute domain, but sometimes extend into the halo. Of course not every application using gt4py will use halos, so we also need to be careful to not bake in that as a required specification by the user.

We propose adding a new gtscript keyword of 'boundary' that applies the stencil under it on a subset of the local domain, when the local domain includes the global region specified.

It is not yet clear what part of the process should be in 'charge' of deciding whether the local region includes a global subregion (e.g. user, front-end, gt4py, backend), and what inside of 'boundary' should pass to the backend. One idea:

The specification of the boundary could be a 'Box,' upon which the user can add abstraction to give it useful meaning. e.g.

.. code-block:: python

  with boundary(Box(slice(-1+grid.global_istart, 1+grid.global_istart), slice(0, None))), interval(...):

where grid.global_istart is the global start index of the region in the first dimension. Dimension names of 'i' and 'j' would not be required or tied to GT4py, but rather a user could defined a Box of any dimensionality matching the arrays they pass in excluding the last dimension, which would still the 'vertical' tied to 'with interval'. Missing from this would be if the boundary conditions need a computation direction for the vertical. This is an unlikely scenario, but perhaps it could be done with something like:

.. code-block:: python

  with boundary(Box(slice(-1+grid.global_istart, 1+grid.global_istart), slice(0, None))),computation(FORWARD), interval(...)

To make this idea more general: 
When `boundary(expression)` is executed inside a stencil, `expression` will be evaluated explicitly in Python in the scope of the module where the stencil is defined. For example, if you write `boundary(my_func(MODULE_VAR))`, then the stencil will call `my_func` at compilation time passing it the value that MODULE_VAR takes at compilation time.

`with boundary(region_obj):` will execute on the local region specified by `region_obj.local_origin` (the start of the region) and `region_obj.extent` (the shape of the region). If region_obj.extent is of size zero in any dimension, the block will not execute (meaning the local domain is not in the global region this stencil applies to). 

We could also require the region_obj include a `region_obj.do_compute` flag to indicate whether this rank should actually do the computation or not. This information could be utilized by the backend to optimize not computing unnecessary stencils. 

Multiple regions could be specified using e.g. `with boundary(obj1, obj2):`. In this case, the computation occurs over all given regions (i.e. the union of the regions)

Then it would be up to the user to define a 'region_obj' object that has attributes/methods that implement the above requirements. Providing a simple base class example could be helpful. 

From that, a user could abstract the 'region_obj' further for particular Edges/Corners, e.g. WestEdge, and define it such that inside the stencil they would just need to say:
with boundary(WestEdge(-1, 1)):
Where the numbers are offsets from the global grid.istart
and all of the information the backend needs would be available in the WestEdge object. 



* Additionally, we should consider the implications of running stencils that do calculations into the halo region of subdomains. 

.. code-block:: python

  def q_i_stencil(q:  FIELD_TYPE, area: FIELD_TYPE, yfx:  FIELD_TYPE, fy2:  FIELD_TYPE, ra_y:  FIELD_TYPE, q_i:  FIELD_TYPE):
    with computation(PARALLEL)
        with interval(...):
           fyy = yfx * fy2
           q_i[0, 0, 0] = (q * area + fyy - fyy[0, 1, 0]) / ra_y
       with boundary(WestEdge(-3, 1)):
           q_i[0 0, 0] = fyy / ra_y
       with boundary(SouthEdge(-3, 1)):
           q_i[0 0, 0] = fyy / ra_y
  q_i_stencil(q, area, yfx, fy2, ra_y, q_i, origin=(i_start_domain, j_start_compute, 0),domain=(nid, njc + 1, nz))

  In this case the interval(...) would operate over 0:nid, halo:njd - halo + 1. But the predefined WestEdge and SouthEdge would still be relative to (global_istart_compute, global_jstart_compute), or (halo, halo). So both edges would be on 0:halo+1 in the global domain, disregarding the local compute domain set with the 'origin' and domain.. It would be confusing if their meaning shifted to be relative to the compute domain defined by the stencil call's origin and domain. Rather, these specifications would not be tied to how the stencil is called.

  Because of the potential confusion this might cause, it would be great to also include warnings when a stencil is run if it leave gaps in cells it computes on. Sometimes this is desired behavior, but more likely would be user error.

  If there are overlaps in boundary and interval specifications, a warning might be useful, but the later ones should 'win', and the backend should detect this case in deciding whether it can run sections in parallel or not.

* Here is an example that has special corner handling:

.. code-block:: python

  SWCorner(starti, endi, startj, endj) -> Box(slice(starti + global_istart, endi + global_istart), slice(startj + global_jstart, endj + global_jstart))​
  SECorner(starti, endi, startj, endj) -> Box(slice(starti + global_iend, endi + global_iend), slice(startj + global_jstart, endj + global_jstart))​
  NWCorner(starti, endi, startj, endj) -> Box(slice(starti + global_istart, endi + global_istart), slice(startj + global_jend, endj + global_jend))​
  NECorner(starti, endi, startj, endj) -> Box(slice(starti + global_iend, endi + global_iend), slice(startj + global_jend, endj + global_jend))​

  @gtscript.stencil(backend="dawn:gtmc", partitioner=partitioner)
  def brbl_stencil(q: FIELD_TYPE, al: FIELD_TYPE, br: FIELD_TYPE, bl: FIELD_TYPE):
    with computation(PARALLEL), interval(...):
        br = al[0, 1, 0] - q
    with boundary(SWCorner(-1, 0, 0, 1), SECorner(0, 1, 0, 1), NWCorner(-1, 0, 1, 2), NECorner(0, 1, 1, 2)), interval(...):
        br = 0
    with computation(PARALLEL), interval(...):
        bl = br[-1, 0, 1]  + al

​  # calling the stencil
  brbl_stencil(al, q, br, origin=(local_istart - 1, local_jstart, 0), domain=(local_ni + 1, local_nj, nk))

 
* More complicated stencils with reusable gtscript function will still yield unecessary duplicated specification. One idea would be to allow us to express the 'with computation' specifications inside a gtscript.stencil. For example :

.. code-block:: python

  with computation(PARALLEL), interval(...):
        adv_u, adv_v = advection(dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)
        diff_u, diff_v = diffusion(dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)

If both advection and diffusion stencils have horizontal domain handling at boundaries, it'd have to look something like

.. code-block:: python

  with computation(PARALLEL): 
      with interval(...):
        adv_u, adv_v = advection(dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)
      with boundary(Edges):
        adv_u, adv_v = advection_edges (dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)
      with interval(...):
        diff_u, diff_v = diffusion(dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)
      with boundary(Edges):
        diff_u, diff_v = diffusion_edges(dx=dx, dy=dy, u=in_u_tmp, v=in_v_tmp)

This could be an initial version, but a useful feature would be to be able to specify 'with interval' or 'with boundary' inside a gtscript function, so the top version could still be used, and edges/corners could be specified inside of it

* An additional feature that might be helpful for some is the ability to specify offsets to global variables with variables rather than hard coded values. Then stencils with common patterns could be reused in a number of cases e.g.

.. code-block:: python

  @gtscript.stencil(backend=backend, partitioner=partitioner, externals={'offset_start': -1, 'offset_end': 1})
  def reusable_stencil(a: FIELD_TYPE, b: FIELD_TYPE, c: FIELD_TYPE):
    from __externals__ import offset_start, offset_end
    with computation(PARALLEL), interval(...):
         a = b * c
    with boundary(WestEdge(offset_start, offset_end)):
         a = b * c + 0.002



Related Work
------------
The dawn backend already has a concept of domain decomposition per mpi rank and global iteration spaces. 


Implementation
--------------
* A first step would generating the 'boundary' functionality to include the horizontal dimension subdomain operations
* Implement a basic region_obj and determine what it must provide
* If possible it should be implemented using a backend that already has a concept of global iteration spaces built-in, and then expand to the numpy backend and others. 
* Add support for 'union' or similar concept for expressing multiple regions in one interval, to avoid duplicating stencil expressions
* Ensure and test that this feature can be applied for N-d arrays
* expand the capabilities of gtscript.function to include 'with computation' and 'with boundary' blocks


Alternatives
------------
There are a number of slight modifications possible to how this is expressed in the front-end. 

1. Multidimensional 'intervals'
Expand the 'interval' specification to include horizontal global ranges with a similar 'region' object as the proposed solution. But instead of introducing a new 'boundary' keyword, we could incorporate specification of the horizontal bounds into the existing keywords. It's perhaps a little confusing, because the 'with computation(X)' still refers to the ordering of just the vertical direction, while the 'with interval' would be specified in more than one dimension. We could rename 'with computation' to 'with vertical_computation', or something similar, but then we lose backward compatibility. With this idea, the interval could specify an arbitrary number of box bounds.

.. code-block:: python

  Vertical(start, end) -> Column(k=slice(start, end))​
  @gtscript.stencil(backend=dawn, partitioner=partitioner)​
  def ubke(uc: FIELD_TYPE, vc: FIELD_TYPE, cosa: FIELD_TYPE, rsina: FIELD_TYPE, ub: FIELD_TYPE, ut: 
  FIELD_TYPE, dt4: float, dt5: float):​
    with computation(gtscript.PARALLEL):​
      with interval(...): # indicates compute domain specified with 'origin' and 'domain'
        ub = dt5 * (uc[0, -1, 0] + uc - (vc[-1, 0, 0] + vc) * cosa) * rsina​
      with interval(Vertical(0, None), (WestEdge(0, 1), EastEdge(0, 1)):​
        ub = dt5 * (ut[0, -1, 0] + ut)​
      with interval((SouthEdge(0, 1), NorthEdge(0, 1))):​
        ub = dt4 * (-ut[0, -2, 0] + 3.0 * (ut[0, -1, 0] + ut) - ut[0, 1, 0])​

In this case we'd have special 'Vertical' objects for slicing the vertical direction. 
We have not rejected this as a possible solution. This might lend itself more naturally to expanding to an arbitrary Nd array. The main downside is that it would not preserve bakcwards compatibility as well as the 'special boundary' solution. Most of the features mentioned above could just as easily be done in this solution as the proposed, it's more of a syntactic difference.


2. Explicit indices
 
This solution is similar to 1), but is more explicit. This will be more familiar to Fortran model developers. But, it is more tedious than some of the other solutions, so a python developer may be tempted to add another translation layer to allow abstraction of duplicated patterns. Instead of offsets from a compute domain, specify absolute global indices within the stencil with variables. e.g. here i_s and i_e are variables representing the start and end of the compute domain in the first dimension of a 3d array. It's be up to the user to define what these are.  Add these specifications within the existing 'interval' keyword. This would not be back compatible unless we allowed interval(k_s:k_e) to mean interval(:, :, k_s:k_e). When running on subtiles, the backend would determine what the global indices of the subdomain is and whether or not to run each of the interval expressions. 

A major problem with this approach is that it requires the backend to know about the global iteration space. We may be able to implement handling for Dawn, but this wouldn't work for most backends, and would be hard to generalize. 

.. code-block:: python

  @gtscript.stencil()
  def ubke(uc: FIELD_TYPE, vc: FIELD_TYPE, cosa: FIELD_TYPE, rsina: FIELD_TYPE, ub: FIELD_TYPE, *, dt4: float, dt5: float):
    with computation(gtscript.PARALLEL), 
      with interval(i_s:i_e, j_s:j_e, k_s:k_e):
        ub = dt5 * (uc[0, -1, 0] + uc - (vc[-1, 0, 0] + vc) * cosa) * rsina
      # West edge
      with interval(i_e-1:i_e, :, :):
        ub = dt5 * (ut[0, -1, 0] + ut)
      # East edge
      with interval(i_e:i_e+1, :, :):
        ub = dt5 * (ut[0, -1, 0] + ut)
      # South edge
      with interval(:,j_s:j_s+1, :):
        ub = dt4 * (-ut[0, -2, 0] + 3.0 * (ut[0, -1, 0] + ut) - ut[0, 1, 0])
      # North edge
      with interval(:, j_e:j_e+1, :):
        ub = dt4 * (-ut[0, -2, 0] + 3.0 * (ut[0, -1, 0] + ut) - ut[0, 1, 0])
      
3. Partitioner outside stencil      
Have a partitioner object that has awareness of the model decomposition make the calls. Use methods it has to specify subdomains.

.. code-block:: python

  def ub(uc, vc, ub, dt4, dt5, partitioner):  # new SubtilePartitioner object
    with partitioner.center(uc) as domain:
        main_ub(uc,vc,grid.cosa,grid.rsina,ub,dt5=dt5,origin=domain.origin, domain=domain.extent,)
    with partitioner.tile_west(ut, start=0, end=1) as domain:  
        x_edge(ut, ub, dt5=dt5, origin=domain.origin, domain=domain.extent)
    with partitioner.tile_south(ut, start=0, end=1) as domain:
        y_edge(ut, ub, dt4=dt4, origin=domain.origin, domain=domain.extent)
    with partitioner.tile_north(ut, start=-1, end=0) as domain:
        y_edge(ut, ub, dt4=dt4, origin=domain.origin, domain=domain.extent)
    with partitioner.tile_east(ut, start=-1, end=0) as domain:
        x_edge(ut, ub, dt5=dt5, origin=domain.origin, domain=domain.extent)

This is similar to the idea of a region object, but is more directly using a user defined object rather than a special boundary keyword. It is unclear how this would translate to the backend.


Discussion
----------

This issue is related to this discussion, a precursor to this proposal:
https://github.com/GridTools/gt4py/issues/9
It is an alternative approach to the backend optimization of corners and edges. 

References and Footnotes
------------------------

.. [1] Each GDP must either be explicitly labeled as placed in the public domain (see
   this GDP as an example) or licensed under the `Open Publication License`_.

.. _Open Publication License: https://www.opencontent.org/openpub/


Copyright
---------

This document has been placed in the public domain. [1]_
